type Query {
  users: [User!]!
  ingredients: [Ingredient!]!
  recipes: [Recipe!]!
  tags: [Tag!]
  messages: [Message!]
  comments: [Comment!]!
  ratings: [Rating!]!

  user(name: String!): User
  ingredient(name: String!): Ingredient
  recipe(name: String!): Recipe
  tag(name: String!): Tag
  message(_id: ID!): Message
  comment(_id: ID!): Comment
  rating(_id: ID!): Rating

  recipeSearch(_id: ID!): Recipe
}

type Mutation {
  createMessage(
    addresseeID: Int!
    senderID: Int!
    title: String!
    message: String!
    timestamp: Long!
  ): Message
  createUser(name: String!, password: String!): Token!
  createRecipe(
    name: String!
    description: String!
    difficulty: Difficulty!
    image: String!
    time: Int!
    tag: [TagInput!]
    ingredient: [IngredientInput!]!
    userID: Int!
  ): Recipe
  login(name: String!, password: String!): Token!
}

enum Difficulty {
  EASY
  NORMAL
  HARD
}

scalar Long

type User {
  id: ID
  name: String!
  password: String!
  friends: [User] @relation(name: "WATCHES", direction: "OUT")
  recipe: [Recipe]
    @relation(name: "POSTS", direction: "OUT")
    @cypher(statement: "MATCH (this)-[:POSTS]->(r:Recipe) RETURN r")
}

type Message {
  id: ID
  addressee: User! @relation(name: "SENT_TO", direction: "IN")
  sender: User!
  title: String!
  message: String!
  timestamp: Long!
}

type Ingredient @isAuthenticated {
  name: String!
  amount: String
}

input IngredientInput {
  name: String!
  amount: String
}

input TagInput {
  name: String!
}

input RatingInput {
  rate: Int!
}

input CommentInput {
  rating: RatingInput!
  description: String!
}

type Tag {
  name: String!
  recipes: [Recipe] @relation(name: "HAS_TAG", direction: "IN")
}

type Recipe {
  id: ID
  name: String!
  description: String!
  difficulty: Difficulty!
  image: String!
  totalCost: Int
  time: Int!
  tag: [Tag]! @relation(name: "HAS_TAG", direction: "OUT")
  user: User
    @relation(name: "POSTS", direction: "IN")
    @cypher(statement: "MATCH (this)<-[:POSTS]-(u:User) RETURN u")
  ingredient: [Ingredient] @relation(name: "HAS_INGREDIENT", direction: "OUT")
  comment: [Comment] @relation(name: "POSTS", direction: "OUT")
}

type Comment @isAuthenticated @relation(name: "POSTS") {
  rating: Rating! @relation(name: "HAS_RATING", direction: "OUT")
  description: String!
}

type Rating @isAuthenticated {
  rate: Int! @relation(name: "HAS_RATING", direction: "IN")
}

type Token {
  token: String!
  userID: String!
}
