scalar Long
scalar EmailAddress

enum Difficulty {
  EASY
  NORMAL
  HARD
}

type Subscription {
  messageRecived(id: ID!): Message
}

type Query {
  users: [User!]!
  ingredients: [Ingredient!]!
  recipes: [Recipe!]!
  tags: [Tag!]
  messages: [Message!]
  comments: [Comment!]!
  ratings: [Rating!]!

  user(name: String): User
  ingredient(name: String): Ingredient
  recipe(name: String): Recipe
  tag(name: String): Tag
  message(name: String): Message
  comment(_id: ID): Comment
  rating(_id: ID): Rating

  recipeSearch(_id: ID!): Recipe
}

type Mutation {
  createMessage(
    addresseeID: Int!
    senderID: Int!
    title: String!
    message: String!
    timestamp: Long!
  ): Message

  createRecipe(
    name: String!
    description: String!
    difficulty: Difficulty!
    image: String!
    time: Int!
    tag: [TagInput!]
    ingredient: [IngredientInput!]!
    userID: Int!
  ): Recipe

  createUser(name: String!, password: String!): Credentials!
  editUser(user: EditUserInput): Credentials!
  login(name: String!, password: String!): Credentials!
}

input EditUserInput {
  oldName: String!
  name: String
  email: EmailAddress
  password: String
  avatar: String
  description: String
}

type User {
  id: ID
  name: String!
  email: EmailAddress
  password: String!
  avatar: String
  description: String
  friends: [User] @relation(name: "WATCHES", direction: "OUT")
  recipe: [Recipe]
    @relation(name: "POSTS", direction: "OUT")
    @cypher(statement: "MATCH (this)-[:POSTS]->(r:Recipe) RETURN r")
}

type Message {
  id: ID
  addressee: User! @relation(name: "SENT_TO", direction: "OUT")
  sender: User! @relation(name: "SENT_FROM", direction: "OUT")
  title: String!
  message: String!
  timestamp: Long!
}

type Ingredient @isAuthenticated {
  name: String!
  amount: String
}

type Credentials {
  token: String!
  user: User!
}

input IngredientInput {
  name: String!
  amount: String
}

input TagInput {
  name: String!
}

input RatingInput {
  rate: Int!
}

input CommentInput {
  rating: RatingInput!
  description: String!
}

type Tag {
  name: String!
  recipes: [Recipe] @relation(name: "HAS_TAG", direction: "IN")
}

type Recipe {
  id: ID
  name: String!
  description: String!
  difficulty: Difficulty!
  image: String!
  totalCost: Int
  time: Int!
  tag: [Tag]! @relation(name: "HAS_TAG", direction: "OUT")
  user: User
    @relation(name: "POSTS", direction: "IN")
    @cypher(statement: "MATCH (this)<-[:POSTS]-(u:User) RETURN u")
  ingredient: [Ingredient] @relation(name: "HAS_INGREDIENT", direction: "OUT")
  comment: [Comment] @relation(name: "POSTS", direction: "OUT")
}

type Comment @isAuthenticated @relation(name: "POSTS") {
  rating: Rating! @relation(name: "HAS_RATING", direction: "OUT")
  description: String!
}

type Rating @isAuthenticated {
  rate: Int! @relation(name: "HAS_RATING", direction: "IN")
}

type Token {
  token: String!
}
